객체와 관계형 데이터베이스의 차이
    상속
    연관관계(참조)
     참조 : PK, FK
    객체는 단방향, DB는 양방향 데이터 조회 가능

JPA(Java Persistence API)
    자바 진영의 ORM 기술 표준
        Object-relational mapping(객체 관계 매핑)
    객체는 객체대로 관계형 DB는 관계형 DB 대로 설계
    ORM 프레임워크가 중간에서 매핑
    **패러다임의 불일치 해결

JPA 역사
    EJB - 엔티티 빈(자바 표준)
    하이버네이트(오픈 소스)
    JPA(자바 표준) - 하이버네이트를 많이 참조하여 만듦

사용이유
    SQL 중심 개발 -> 객체 중심 개발
    생산성
    유지보수

성능 최적화 기능
    1차 캐시와 동일성 보장
    같은 트랙잭션 안에서는 같은 엔티티 반환
        Member m1 = jpa.find("");
        Member m2 = jpa.find("");
        m1 == m2
        // SQL 한번만 실행
    트랜잭션을 지원하는 쓰기 지연
        트랙잭션을 커밋할 때까지 INSERT SQL을 모음
        JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송
            transaction.begin();

            em.persist(memberA);
            em.persist(memberB);
            em.persist(memberC);
            // 쿼리를 수행하지 않는다.

            transaction.commit();
            // 일괄 쿼리 수행
    지연 로딩과 즉시 로딩
        지연 로딩 : 객체가 실제 사용될때 로딩
            select 이후 select
        즉시 로딩 : JOIN SQL로 한번에 연관된 객체까지 미리 조회(JPA 옵션으로 사용)
            select join

*** JPA 모든 작업은 Transaction 안에서 해야한다.
안그러면 작업이 안된다.

JPQL(SQL을 추상화한 객체 지향 쿼리 언어, 객체 지향 SQL)
    JPQA를 사용하면 엔티티 객체를 중심으로 개발
    SQL은 데이터베이스 테이블을 대상으로 개발
    검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색(특정 데이터베이스 SQL에 의존하지 않음, 방언으로 쿼리를 자동 생성해준다)
    모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능
    애플리케이션이 필요한 데이터만 DB에서 불러오려면 쿼리를 사용해야함.

JPA 가장 중요한 2가지
    객체와 관계형 데이터베이스 매핑(Object Relation Mapping)

    영속성 컨텍스트


엔티티 매니저 팩토리(EntityManagerFactory)
    엔티티 매니저(EntityManager)

영속성 컨테스트
    엔티티를 영구 저장하는 환경
    영속성 컨테스트에 저장
        EntityManager.persist(entity);  // 1차 캐시에 저장, INSERT SQL 생성하여 쓰기 지연 SQL 저장소에 저장
    엔티티 매니저를 통해서 영속성 컨텍스트에 접근

    비영속
        객체를 생성한 상태
        Member member = new Member();
    영속
        em.persist(member);
    준영속 상태
        em.detach(member);
    삭제
        em.remove(member);
영속성 컨텍스트의 이점
    1차 캐시
    동일성(identity) 보장
변경 감지(Dirty Checking)
    수정시 스냅샷을 통해 기존 엔티티와 비교하여 변경이 있는 경우 수정 쿼리 생성
지연 로딩(Lazy Loading)
flush(
    영속성 컨텍스트의 변경 내용을 즉시 데이터베이스에 반영

엔티티 매핑
    객체 - 테이블 : @Entity, @Table
    필드 - 컬럼 : @Column
    기본 키 : @Id
    연관관계 매핑 : @ManyToOne, @JoinColumn



** JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수
기본 생성자 필수
final 클래스, enum, interface, inner 클래스 사용 X
저장할 필드에 final X


기본키 매핑
@Id
    직접할당
@GeneratedValue
    IDENTITY
        commit 이전에 키값 확인이 불가능하다.
        JPA 에서 persist 하는 순간 INSERT 쿼리를 자동 수행한다. 따라서 persist 이후 해당 객체에 키값을 자동으로 넣어준다.
    SEQUENCE
        persist 하는 순간 select sequenct 쿼리를 수행하여 id 값에 set해줌
    AUTO
    자동 생성
        ORACLE SEQUENCE


객체와 테이블 연관관계 매핑
    테이블 지향 모델링인 경우 객체 지향적이지 않음.
    객체 연관관계 사용해야함.
        단방향 연관관계
            @ManyToOne // 1:N 관계
            @JoinColumn(name ="")
        양방향 연관관계
            양쪽에서 참조하도록 작업
            ** mappedBy
            객체 연관관계 = 2개(양방향이라 부름)
                회원 -> 팀
                팀 -> 회원
                객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야함
            테이블 연관관계 = 1개
                외래키 하나로 두 테이블의 연관관계 관리
             양방향 매핑 규칙
                객치의 두 관계자중 하나를 연관관계의 주인으로 지정
                연관관계의 주인만이 외래 키를 관리(등록, 수정)
                주인이 아닌 쪽은 읽기만 가능
                주인은 mappedBy 속성 사용 X
                주인이 아니면 mappedBy 속성으로 주인 지정
                외래키가 있는 곳을 주인으로 결정(1:N 에서 N 쪽이 주인이됨)

단방향 매핑만으로도 연관관계 매핑은 완료된다
    양방향 매핑은 반대 방향 조회 기능일 뿐임.
    양방향 매핑은 개발시 필요할때 넣어라.
    편의성을 위해 양방향 매핑이 필요한 경우가 생긴다.


테이블
    외래키 하나로 양쪽 조인 가능(방향이라는 개념이 없음)
객체
    참조용 필드가 있는 쪽으로만 참조 가능
    한쪽만 참조하면 단방향
    양쪽이 서로 참조하면 양방향(사실 단방향이 두개다)
다대일(N:1)
    DB는 N 쪽에 외래키가 설정 되어있다.
    N 쪽이 연관관계 주인이 된다.
일대다(1:N) - 사용하지 말것.
    - JPA에서는 거의 사용하지 않는 모델링임.
    '1'이 연관관계 주인이 된다.
        엔티티가 관리하는 외래 키가 다른 테이블에 있음.
        연관관계 관리를 위해 추가로 UPDATE SQL 실행
    @OneToMany 사용시 연결되는 테이블 하나가 생성된다..
    다대일 양방향 매핑을 사용하는것을 권장함.
    일대다 양방향 매핑도 존재하나... 공식적으로 사용은 안된다
        읽기 전용 필드를 사용해서 양방향처럼 사용
일대일
    외래키 선택 가능
다대다
    편리해 보이지만 실무에서는 사용 X
    중간 테이블을 사용하여 처리하는 방식


